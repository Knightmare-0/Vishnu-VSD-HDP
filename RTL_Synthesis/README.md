# Vishnu-VSD-HDP
# VSD-HDP Status

## Day_0
*Before installing run the command below*
```
$ sudo apt update && upgrade
```
Tools needed:
- [x] Yosys
- [x] OpenSTA
- [x] ngspice
- [x] iverilog
- [x] gtkwave
- [x] magic

### Yosys
```
$ mkdir yosys
$ git clone https://github.com/YosysHQ/yosys.git
$ cd yosys
$ sudo apt-get install build-essential clang bison flex \
    libreadline-dev gawk tcl-dev libffi-dev git \
    graphviz xdot pkg-config python3 libboost-system-dev \
    libboost-python-dev libboost-filesystem-dev zlib1g-dev
$ make 
$ sudo make install
```

![yosys](https://user-images.githubusercontent.com/112769624/236633099-02d75838-aa08-46c7-b303-7905add62979.png)



### OpenSTA
*To install cmake for 18.04 (if not present)*
```
$ wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | sudo apt-key add -
$ sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ bionic main'
$ sudo apt-get update
$ sudo apt-get upgrade
```
*Dependency*
```
$ sudo apt install swig
```
*For OpenSTA*
```
$ git clone https://github.com/The-OpenROAD-Project/OpenSTA.git
$ cd OpenSTA
$ mkdir build
$ cd build
$ cmake ..
$ make
```
![sta](https://user-images.githubusercontent.com/112769624/236634039-9f27788e-8a0f-4f94-94f3-f5ba59ed7f3a.png)


### ngspice
* Download ngspice-37.tar.gz from old releases parent folder from
(https://sourceforge.net/projects/ngspice/files/)
```
$ tar -zxvf ngspice-40.tar.gz
$ cd ngspice-40
$ mkdir release
$ cd release
$ ../configure  --with-x --with-readline=yes --disable-debug
$ make
$ sudo make install
```
![ngspice](https://user-images.githubusercontent.com/112769624/236634603-e17ae7a4-9e6a-4ec5-bd67-8898ae467085.png)


### iverilog
```
$ sudo apt-get install iverilog
```
### gtkwave
```
$ sudo apt install gtkwave
```
### magic
```
$   sudo apt-get install m4
$   sudo apt-get install tcsh
$   sudo apt-get install csh
$   sudo apt-get install libx11-dev
$   sudo apt-get install tcl-dev tk-dev
$   sudo apt-get install libcairo2-dev
$   sudo apt-get install mesa-common-dev libglu1-mesa-dev
$   sudo apt-get install libncurses-dev
```
##Day_1

### Good MUX design and testbench

![iverilog sim](https://user-images.githubusercontent.com/112769624/236661360-f3b70813-89fc-41de-87fb-a54129a675ae.png)

*Presequisites*
```
$ sudo apt install vim-gtk3
```
*commands*
```
$ gvim good_mux.v tb_good_mux.v
$ gedit good_mux.v tb_good_mux.v
$ iverilog good_mux.v tb_good_mux.v
$ ls
$ ./a.out
$ gtkwave tb_good_mux.v

```
*MUX design*

```
module good_mux (input i0 , input i1 , input sel , output reg y);
always @ (*)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```

*MUX testbench*

```
`timescale 1ns / 1ps
module tb_good_mux;
	// Inputs
	reg i0,i1,sel;
	// Outputs
	wire y;

        // Instantiate the Unit Under Test (UUT)
	good_mux uut (
		.sel(sel),
		.i0(i0),
		.i1(i1),
		.y(y)
	);

	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end

always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
*gtkwave output*
![day1-1](https://user-images.githubusercontent.com/112769624/236661094-f39ac58d-214e-4938-9e4c-ff875f46e0d8.png)

### MUX synthesis to gatelevel netlist

*yosys flow*
![yosys_flow](https://user-images.githubusercontent.com/112769624/236665087-54638e48-cd2e-4f09-bc2e-1b81182186b0.png)


*commands for synthesis*

```
yosys> read_liberty -lib /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop//verilog_files/good_mux.v
yosys> synth -top good_mux 
yosys> abc -liberty /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> show
```
![procedure](https://user-images.githubusercontent.com/112769624/236665583-82ad8f8b-6bf1-4468-8e57-00c9cddfe41a.png)

*ABC results*

![yosys mux res](https://user-images.githubusercontent.com/112769624/236665606-99faab73-96f4-405d-a504-7410652ffbd6.png)

*MUX Netlist*

![mux_netlist](https://user-images.githubusercontent.com/112769624/236665640-d33d6f90-632a-4419-a930-d3d16a1b85b2.png)

*Netlist code using the commands*
```
$ write_verilog -noattr good_mux_netlist.v
$ gedit good_mux_netlist.v
```
*Netlist Code*
```
/* Generated by Yosys 0.28+12 (git sha1 4251d37f4, clang 10.0.0-4ubuntu1 -fPIC -Os) */

module good_mux(i0, i1, sel, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  input i0;
  wire i0;
  input i1;
  wire i1;
  input sel;
  wire sel;
  output y;
  wire y;
  sky130_fd_sc_hd__mux2_1 _4_ (
    .A0(_0_),
    .A1(_1_),
    .S(_2_),
    .X(_3_)
  );
  assign _0_ = i0;
  assign _1_ = i1;
  assign _2_ = sel;
  assign y = _3_;
endmodule
```
## Day_2
### Hirarchical synthesis and Flattened synthesis

*Commands for hirarchical synthesis*
```
yosys> read_liberty -lib /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> read_verilog /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop//verilog_files/good_mux.v
yosys> synth -top multiple_modules 
yosys> abc -liberty /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
yosys> show
yosys> write_verilog -noattr multiple_modules_hirar.v
yosys> !gedit multiple_modules_hirar.v
```
*Output netlist and module*

![hirar_syn](https://user-images.githubusercontent.com/112769624/236819016-d610881c-1166-4e52-863b-47217f667920.png)

```
/* Generated by Yosys 0.28+12 (git sha1 4251d37f4, clang 10.0.0-4ubuntu1 -fPIC -Os) */

module multiple_modules(a, b, c, y);
  input a;
  wire a;
  input b;
  wire b;
  input c;
  wire c;
  wire net1;
  output y;
  wire y;
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

module sub_module1(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  input a;
  wire a;
  input b;
  wire b;
  output y;
  wire y;
  sky130_fd_sc_hd__and2_0 _3_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  assign _1_ = b;
  assign _0_ = a;
  assign y = _2_;
endmodule

module sub_module2(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  input a;
  wire a;
  input b;
  wire b;
  output y;
  wire y;
  sky130_fd_sc_hd__or2_0 _3_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  assign _1_ = b;
  assign _0_ = a;
  assign y = _2_;
endmodule

```
*Commands for flattend synthesis*

*insert following command after synthesis*
```
yosys> flatten
yosys> write_verilog -noattr multiple_modules_flat.v
yosys> !gedit multiple_modules_flat.v
```
*Output netlist and module*

![flattened_synth](https://user-images.githubusercontent.com/112769624/236819091-f60ab187-0700-499b-ac07-ad9bb7060b06.png)

```
module multiple_modules(a, b, c, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  wire _4_;
  wire _5_;
  input a;
  wire a;
  input b;
  wire b;
  input c;
  wire c;
  wire net1;
  wire \u1.a ;
  wire \u1.b ;
  wire \u1.y ;
  wire \u2.a ;
  wire \u2.b ;
  wire \u2.y ;
  output y;
  wire y;
  sky130_fd_sc_hd__and2_0 _6_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  sky130_fd_sc_hd__or2_0 _7_ (
    .A(_4_),
    .B(_3_),
    .X(_5_)
  );
  assign _4_ = \u2.b ;
  assign _3_ = \u2.a ;
  assign \u2.y  = _5_;
  assign \u2.a  = net1;
  assign \u2.b  = c;
  assign y = \u2.y ;
  assign _1_ = \u1.b ;
  assign _0_ = \u1.a ;
  assign \u1.y  = _2_;
  assign \u1.a  = a;
  assign \u1.b  = b;
  assign net1 = \u1.y ;
endmodule
```
## Flops 

*synchronous reset and asynchronous reset in flops*

*1> asynchronous reset*
```
module dff_asyncres(input d,input clk,input asyncres,output reg q)
  always @(posedge clk , posedge asyncres)
    begin
    if(asyncres)
      q <= 1'b0;
  	else
      q <= d;
    end
endmodule
```
*2> synchronous reset*
```
module dff_asyncres(input d,input clk,input syncres,output reg q)
  always @(posedge clk)
    begin
    if(syncres)
      q <= 1'b0;
  	else
      q <= d;
    end
endmodule
```
*3> both synchronous and asynchronous reset*
```
module dff_asyncres(input d,input clk,input syncres,input ayncres,output reg q)
  always @(posedge clk, posedge asyncres)
    begin
    if(asyncres)
      q <= 1'b0;
    else if(syncres)
      q <= 1'b0;
    else
      q <= d;
    end
endmodule
```
*command for synthesis of 1 and 2 in yosys*
```
yosys> read_liberty -lib /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> read_verilog /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/verilog_files/dff_asyncres.v
yosys> synth -top dff_asyncres 
yosys> dfflibmap -liberty /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> abc -liberty /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> show
yosys> read_verilog /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/verilog_files/dff_syncres.v 
yosys> synth -top dff_syncres 
yosys> dfflibmap -liberty /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> abc -liberty /home/knightmare/vlsi/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
yosys> show
```
![asyncres_dff](https://user-images.githubusercontent.com/112769624/236834419-d00e964f-7ae3-45d8-9041-ca7cd9c54856.png)
![asyncres_gtkwave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/e1ccf3f2-169b-4263-bc44-58621c0fcdb7)

![dff_syncres](https://user-images.githubusercontent.com/112769624/236834488-db937766-d0e4-42b8-b04e-1910e0f1a14f.png)
![syncress_dff_gtkwave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/930e3537-ee69-4393-908d-c4ace1a704c1)

*Note : synchronous logic is realized using a nor logic*
	*dfflibmap maps to all dff's*
## interesting optimization 
*Special cases where there is wired logic used instead of multipliers*

*1> Code 1*
```
module mul2 (input [2:0] a, output [3:0] y);
	assign y = a * 2;
endmodule
```
*synthesis output*

![a*2](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/6cbcf6c6-472e-4d30-8edc-e4fecebc84fb)

*2> Code 2*
```
module mult8 (input [2:0] a , output [5:0] y);
	assign y = a * 9;
endmodule
```

*synthesis output*

![a*9](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/9651e292-4801-4d09-84d0-8b8bc31e6d86)

### DAY 3
## combinational logic optimization
*following commands are used for optimization after synthesis*
```
yosys> opt_clean -purge
```
*NOTE : use flatten for multiple modules*


*code opt_check*
```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```
*synthesis reduced to AND gate*

![opt_check](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/861099b2-5e07-49e8-9672-18b8d78d2a66)

*code opt_check2*
```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
*synthesis reduced to OR gate*
![opt_check2](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/05ef6e22-77b0-425a-970e-8dadd0c5f7da)

*code opt_check3*
```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
*synthesis reduced to 3 input AND gate*
![opt_check3](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/a72ba48a-95e1-4828-92d5-86582c876583)

*code opt_check4*
```
module opt_check4 (input a , input b , input c , output y);
assign y = a?(b?(a & c ):c):(!c);
endmodule
```
*synthesis reduced to XOR gate*

![opt_check4](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/c53d9d91-f9d9-4220-9b6b-c0a8d442315a)

*code multiple_module_opt*
```
module sub_module1(input a , input b , output y);
 assign y = a & b;
endmodule


module sub_module2(input a , input b , output y);
 assign y = a^b;
endmodule


module multiple_module_opt(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module1 U1 (.a(a) , .b(1'b1) , .y(n1));
sub_module2 U2 (.a(n1), .b(1'b0) , .y(n2));
sub_module2 U3 (.a(b), .b(d) , .y(n3));

assign y = c | (b & n1); 


endmodule
```
*synthesis optimized using distributive boolean law*
![multiple_module_opt](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/7caa938d-616e-4514-a294-f40765f5b8ac)

*code multiple_module_opt2*
```

module sub_module(input a , input b , output y);
 assign y = a & b;
endmodule



module multiple_module_opt2(input a , input b , input c , input d , output y);
wire n1,n2,n3;

sub_module U1 (.a(a) , .b(1'b0) , .y(n1));
sub_module U2 (.a(b), .b(c) , .y(n2));
sub_module U3 (.a(n2), .b(d) , .y(n3));
sub_module U4 (.a(n3), .b(n1) , .y(y));


endmodule
```
*synthesis optimized for output 0*

![multiple_modules_opt2](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/59aeed7e-64c9-4672-93a2-6183a2dc6376)

## Sequential Optimization
*use command*
```
yosys> dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
```
*for sequential circuits*

*dff_const1 code*
```
module dff_const1(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b0;
	else
		q <= 1'b1;
end

endmodule
```

*dff_const1 waveform analysis*

![dff_const1_wave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/733aaedc-cd84-4596-b604-3d09373a017a)

*dff_const1 synthesis analysis*

![dff_const1_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/02cd3a26-fed4-4514-a559-34bfe65c66ac)

*dff_const2 code*
```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end

endmodule
```
*dff_const2 waveform analysis*

![dff_const2_wave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/a81218ef-4443-4a27-80af-d31edf92f80d)

*dff_const2 synthesis analysis*

![dff_const2_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/8746ef53-9fc9-4fa9-9c01-e36862ad9453)

*dff_const3 code*

```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
![dff_const3](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/89d5efc2-d300-472c-be8b-ce9532216930)

*dff_const2 waveform analysis*

![dff_const3_wave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/bcd2760b-e44d-4e52-93d9-49036ffdda9e)

*Note : dff2 samples 0 at posedge as a result of clock to q delay of dff1 * 

*dff_const2 synthesis analysis*

![dff_const3_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/eefe5375-fb03-42e9-b6a2-b31675bccd77)

*dff_const4 code*
```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```

*dff_const4 waveform analysis*

![dff_const4_wave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/26f8a75b-0216-4d4e-a65d-8b06bff996fa)

*dff_const4 synthesis analysis*

![dff_const4_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/1d18cd05-d8c2-4873-b179-89bf63add021)

*dff_const5 code*
```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```

*dff_const5 waveform analysis*

![dff_const5_wave](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/c113225e-7e17-4ba9-a918-98bb0d118b1a)

*Note : dff2 samples 0 at posedge as a result of clock to q delay of dff1 * 

*dff_const4 synthesis analysis*

![dff_const5_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/6c5816b1-d3b8-4e1a-97db-6833ba14986e)

## unused output optimization

*counter_opt code*
```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
*optimized synthesis*

![counter_opt_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/9e84e284-fd8e-424f-a209-ce6e64bef050)

*counter_opt2 code*
```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = (count[2:0] == 3'b100);

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
*synthesised map*

![counter_opt2_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/41558fbd-3ad9-4108-b6a7-1f05b7d97566)

### Day 4
## Gate Level Simulation
*commands for Gate Level Simulation Using i verilog*
```
knightmare@Wizz-Corp:~/vlsi/sky130RTLDesignAndSynthesisWorkshop/verilog_files$ iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_mux_net.v tb_ternary_operator_mux.v
knightmare@Wizz-Corp:~/vlsi/sky130RTLDesignAndSynthesisWorkshop/verilog_files$ ./a.out
VCD info: dumpfile tb_bad_mux.vcd opened for output.
knightmare@Wizz-Corp:~/vlsi/sky130RTLDesignAndSynthesisWorkshop/verilog_files$ gtkwave tb_ternary_operator_mux.vcd 
```
*1>RTL Simulation and Netlist Simulation of a MUX using a ternary operator*

*Code for MUX using a ternary operator*

```
module ternary_operator_mux (input i0 , input i1 , input sel , output y);
	assign y = sel?i1:i0;
	endmodule
```

*RTL Simulation*

![ter_opt_mux_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/f467a028-31ef-4751-8e41-7b79da11fa39)

*Netlist Simulation*

![ter_opt_mux_gls](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/e4223ec8-a360-4f91-b091-7dd6fd69fd7c)

![ter_mux_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/ddaa260a-53d5-426d-9b3d-afed423b8d04)

*2>Bad MUX*

*Note : Output changes only when select changes in RTL Simulation*

*Bad MUX Code*
```
module bad_mux (input i0 , input i1 , input sel , output reg y);
always @ (sel)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```
*RTL Simulation*

![bad_mux_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/476703f8-20a7-46ea-9cc8-ce569558a612)

*Netlist Simulation*

![bad_mux_netsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/cc5f1b24-936a-4d32-b1f0-f59789cd22d5)

*3>blocking_caveat Simulation Missmatch*

*blocking_caveat code*

```
module blocking_caveat (input a , input b , input  c, output reg d); 
reg x;
always @ (*)
begin
	d = x & c;
	x = a | b;
end
endmodule
```

*RTL Simulation*

![blocking_caveate_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/6f2288ea-b8f4-4049-a3ca-3b1fd191a900)

*Netlist Simulation*

![blocking_caveat_netsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/5ff26c23-4a1c-40e6-ba62-35a46e936a30)

*Netlist Synthesis*

![blocking_caveat_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/7a5ec256-ec1b-479d-b8a9-624429040ed8)

### Day 5

## Incomplete if case constructs

*code for incomplete if*

```
module incomp_if (input i0 , input i1 , input i2 , output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
end
endmodule
```

*RTL Simulation*

![incompif_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/9cc7af74-bfa7-45a4-8549-5859e219f717)

*Note : the output y is given as input to 0th input of the mux (this implies a D-Latch)* 

*Synthesis output*

![incompif_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/298c0f09-4329-491f-8d3f-46661ae40840)

*code for incomplete if 2*

```
module incomp_if2 (input i0 , input i1 , input i2 , input i3, output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
	else if (i2)
		y <= i3;

end
endmodule
```
*RTL Simulation*

![incompif2_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/f8b684ce-6273-455f-b043-e5b62816ee5b)

*Note : The output y is given as input to 0th input of the select i2 mux (this implies a combinational logic is connected to D-Latch enable XOR i1 and i2 as enable)* 

*Synthesis output*

![incomp_if2_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/871a6515-5580-433e-9701-7fec9ccca49f)

*Bad Case Code*
```
module bad_case (input i0 , input i1, input i2, input i3 , input [1:0] sel, output reg y);
always @(*)
begin
	case(sel)
		2'b00: y = i0;
		2'b01: y = i1;
		2'b10: y = i2;
		2'b1?: y = i3;
		//2'b11: y = i3;
	endcase
end

endmodule
```

*RTL Simulation* 

![bad_case_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/d2fce97b-ce31-45e1-aba4-7e850849e3f5)

*Gate Level Simulation*

![bad_case_gls](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/8098fff8-f070-48cf-ace6-4f1d76ab3a80)

*Bad Case Synthesis*

![bad_case_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/4fa3f1a0-571e-4a44-bf5a-ba9cacee06d0)

*Complete Case Code*

```
module comp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
always @ (*)
begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
		default : y = i2;
	endcase
end
endmodule
```

*RTL Simulation*

![compcase_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/36e3b464-33df-4042-b157-de2df62129c5)

*Synthesis Output*

![compcase_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/807c2749-fac3-40b5-bb35-70e8dda02f69)

*Incomplete Case Code*

```
module incomp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
always @ (*)
begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
	endcase
end
endmodule
```

*RTL Simulation*

![incomplete_case_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/b2e7aff9-36f0-4716-83d6-8b56951331b0)

*Synthesis Output*

![incomplete_case_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/78263597-77e8-48a1-bdd8-b76c31d58176)

*Code for Partial Case Assign*
```
module partial_case_assign (input i0 , input i1 , input i2 , input [1:0] sel, output reg y , output reg x);
always @ (*)
begin
	case(sel)
		2'b00 : begin
			y = i0;
			x = i2;
			end
		2'b01 : y = i1;
		default : begin
		           x = i1;
			   y = i2;
			  end
	endcase
end
endmodule
```
*Synthesis Output*

![partial_compcase_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/5674af44-5785-423b-b122-a1c7cd1f48f2)





## Loop Constructs

*Mux Generate Code*
```
module mux_generate (input i0 , input i1, input i2 , input i3 , input [1:0] sel  , output reg y);
wire [3:0] i_int;
assign i_int = {i3,i2,i1,i0};
integer k;
always @ (*)
begin
for(k = 0; k < 4; k=k+1) begin
	if(k == sel)
		y = i_int[k];
end
end
endmodule
```

*RTL Simulation*

![mux_generate_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/be2ab5fc-7006-4c6f-8ff7-b87005d648d5)

*Synthesis Output*

![mux_generate_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/0508913b-cbb4-482e-9783-219d436f795a)

*Demux Codes using case and for generate*

```
module demux_case (output o0 , output o1, output o2 , output o3, output o4, output o5, output o6 , output o7 , input [2:0] sel  , input i);
reg [7:0]y_int;
assign {o7,o6,o5,o4,o3,o2,o1,o0} = y_int;
integer k;
always @ (*)
begin
y_int = 8'b0;
	case(sel)
		3'b000 : y_int[0] = i;
		3'b001 : y_int[1] = i;
		3'b010 : y_int[2] = i;
		3'b011 : y_int[3] = i;
		3'b100 : y_int[4] = i;
		3'b101 : y_int[5] = i;
		3'b110 : y_int[6] = i;
		3'b111 : y_int[7] = i;
	endcase

end
endmodule

module demux_generate (output o0 , output o1, output o2 , output o3, output o4, output o5, output o6 , output o7 , input [2:0] sel  , input i);
reg [7:0]y_int;
assign {o7,o6,o5,o4,o3,o2,o1,o0} = y_int;
integer k;
always @ (*)
begin
y_int = 8'b0;
for(k = 0; k < 8; k++) begin
	if(k == sel)
		y_int[k] = i;
end
end
endmodule
```
*demux case simulation*

![demux_case_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/2318020a-bbc2-48c1-aae3-02ba9045da4d)

*demux for loop simulation*

![demux_generate_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/2044f711-006c-4316-b44a-158267c4b252)

*demux case synthesis*

![demux_case_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/855d194f-10da-4c7d-8b98-8fc666f7d4d5)

*demux for loop synthesis*

![demux_generate_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/4f4c8011-0866-4d24-b109-e58cfd65e2ed)

*Ripple Carry Adder (rca) Code using for generate*

```
module rca (input [7:0] num1 , input [7:0] num2 , output [8:0] sum);
wire [7:0] int_sum;
wire [7:0]int_co;

genvar i;
generate
	for (i = 1 ; i < 8; i=i+1) begin
		fa u_fa_1 (.a(num1[i]),.b(num2[i]),.c(int_co[i-1]),.co(int_co[i]),.sum(int_sum[i]));
	end

endgenerate
fa u_fa_0 (.a(num1[0]),.b(num2[0]),.c(1'b0),.co(int_co[0]),.sum(int_sum[0]));


assign sum[7:0] = int_sum;
assign sum[8] = int_co[7];
endmodule
```
*full adder instansiation code*
```
module fa (input a , input b , input c, output co , output sum);
	assign {co,sum}  = a + b + c ;
endmodule
```
*RTL Simulation*

![rca_rtlsim](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/51a88dea-6f3b-43f7-a3d8-5efaa2cecd9b)

*rca synthesis*

![rca_synth](https://github.com/Knightmare-0/Vishnu-VSD-HDP/assets/112769624/fa133300-108f-46fe-b73d-70ee9e266b04)



















































































































































































































































